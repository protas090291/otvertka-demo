# Service Role Key во фронте: варианты решений

## Где сейчас используется `supabaseAdmin` (service role)

| Файл | Операции |
|------|----------|
| **authApi.ts** | Получение/создание профиля при логине; получение профиля по ID; список пользователей для назначения; **создание пользователя** (auth.admin.createUser); обновление профиля; **удаление пользователя** (auth.admin.deleteUser). |
| **tasksApi.ts** | Создание задачи; чтение задачи по ID; обновление задачи; смена статуса/прогресса; «на проверку» / «выполнено»; смена порядка; удаление задачи. |
| **useSupabase.ts** | Список файлов в Storage (bucket `architectural-plans`) с пагинацией. |
| **DefectsView.tsx** | Список файлов в Storage для дефектов. |

**Риск:** если Service Role Key попадёт в JS-бандл (через `.env.production`), любой пользователь может его достать из браузера и иметь полный доступ к проекту Supabase (обход RLS, удаление данных, создание пользователей и т.д.).

---

## Вариант 1: Бэкенд-прокси (FastAPI)

**Идея:** Service Role Key хранится только на сервере. Фронт вызывает ваш бэкенд (Helper2/backend); бэкенд проверяет JWT пользователя и от его имени выполняет нужные операции в Supabase с service role.

**Что сделать:**
- В бэкенде завести переменные `SUPABASE_URL`, `SUPABASE_SERVICE_ROLE_KEY`.
- Добавить API-маршруты, например:
  - **Auth:** `POST /api/admin/users` (создание), `PATCH /api/admin/users/:id`, `DELETE /api/admin/users/:id`, `GET /api/admin/users/assignable`, `GET /api/admin/users/profile/:id`, создание профиля при первом логине (или через триггер в БД).
  - **Tasks:** `POST /api/tasks`, `GET /api/tasks/:id`, `PATCH /api/tasks/:id`, `DELETE /api/tasks/:id` (и при необходимости отдельные эндпоинты для «на проверку» / «выполнено»).
  - **Storage:** `GET /api/storage/list?path=...` — бэкенд дергает Supabase Storage и возвращает список или подписанные URL.
- На каждом запросе бэкенд принимает заголовок `Authorization: Bearer <jwt>`, проверяет JWT через `supabase.auth.getUser(jwt)` и для админ-операций дополнительно проверяет роль в `user_profiles`.
- Во фронте заменить вызовы `supabaseAdmin` на вызовы этих API (fetch или axios).

**Плюсы:** ключ не попадает в браузер; один центр логики, логи, лимиты.  
**Минусы:** нужно реализовать и поддерживать эндпоинты; бэкенд должен быть поднят на Timeweb.

---

## Вариант 2: Supabase Edge Functions

**Идея:** Админ-операции выполняются в Edge Functions (Deno на Supabase). У каждой функции есть доступ к service role. Фронт вызывает функцию по URL, передаёт свой JWT; функция проверяет роль и выполняет действие.

**Что сделать:**
- В проекте Supabase создать Edge Functions, например: `create-user`, `delete-user`, `update-user-profile`, `task-create`, `task-update`, `task-delete`, `storage-list` и т.д.
- Внутри: чтение JWT из заголовка → проверка через Supabase Auth и/или `user_profiles` (роль admin) → вызов БД/Storage с service role.
- Во фронте заменить использование `supabaseAdmin` на `fetch(supabaseUrl + '/functions/v1/...', { headers: { Authorization: 'Bearer ' + session.access_token } })`.

**Плюсы:** отдельный сервер не нужен, всё в Supabase.  
**Минусы:** нужно писать и деплоить функции; холодный старт; привязка к Supabase.

---

## Вариант 3: Только RLS (без service key во фронте)

**Идея:** Настроить RLS так, чтобы все нужные сценарии работали с **anon-ключом** (один клиент `supabase`). Тогда во фронте вообще не нужен service role.

**Что сделать:**
- **user_profiles:** политики вида: «пользователь видит свой профиль»; «пользователь с ролью admin видит и обновляет любые профили» (проверка через `auth.uid()` и подзапрос к `user_profiles` по роли). Создание профиля при первом логине уже делается триггером в БД — важно, чтобы вставка от имени нового пользователя или от системы была разрешена (например, через политику или через одну Edge Function только для создания профиля).
- **tasks:** политики: создание/чтение/обновление/удаление в зависимости от `user_id`, `created_by_user_id`, `assigned_to` и/или роли в `user_profiles`.
- **Storage:** настроить политики (RLS) на bucket’ах так, чтобы аутентифицированные пользователи (или по ролям) могли делать нужный `list`/`get` без service role.
- **auth.admin.createUser / deleteUser** в Supabase из браузера по RLS недоступны — их нужно оставить в **одном** месте: либо Edge Function (например, `admin-create-user`, `admin-delete-user`), либо бэкенд. То есть полное «только RLS» только для таблиц и storage; для Auth Admin API всё равно один прокси.

**Плюсы:** во фронте только anon key; минимум прокси.  
**Минусы:** нужно аккуратно прописать и протестировать RLS; createUser/deleteUser всё равно через функцию или бэкенд.

---

## Вариант 4: Гибрид (RLS + минимум бэкенда/Edge)

**Идея:** Максимум операций перевести на RLS и anon-ключ; service role использовать только там, где без него нельзя.

**Что сделать:**
1. **Таблицы (tasks, user_profiles):** доработать RLS так, чтобы обычные операции (создание/чтение/обновление задач, чтение/обновление профилей по правилам ролей) выполнялись через обычный клиент `supabase`. После этого во фронте убрать все вызовы `supabaseAdmin` к этим таблицам.
2. **Storage:** настроить политики на bucket’ах и перейти на обычный клиент для `list`/`get` (без supabaseAdmin).
3. **Только Auth Admin:** оставить вызовы `auth.admin.createUser` и `auth.admin.deleteUser` (и при необходимости один раз «создать профиль вручную») в **одной** точке:
   - либо одна Edge Function `admin-auth` (createUser, deleteUser),
   - либо 2–3 эндпоинта на вашем бэкенде (create user, delete user, может, create profile).

В итоге во фронте не передаётся и не подставляется `VITE_SUPABASE_SERVICE_ROLE_KEY`; он используется только на бэкенде или в Edge Function.

**Плюсы:** баланс между объёмом работ и безопасностью; ключ не в браузере.  
**Минусы:** нужны точечные правки RLS и один небольшой прокси (бэкенд или Edge).

---

## Рекомендация

- **Если бэкенд на Timeweb уже планируется** — рационально **Вариант 1** (полный прокси): все вызовы с service role идут через бэкенд, фронт только anon + JWT.
- **Если хочется обойтись без своего сервера** — **Вариант 4**: подтянуть RLS и Storage-политики, вынести в Edge Functions только `createUser`/`deleteUser` (и при необходимости создание профиля). Остальное — через anon и RLS.

Итог по Service Role Key: его не должно быть во фронте. Либо всё админское через бэкенд (Вариант 1), либо через RLS + Edge только для Auth Admin (Варианты 3–4).
